import os
import pickle
from abc import ABC, abstractmethod
from dataclasses import dataclass
from typing import TypeVar, Generic, final

import numpy as np
import pandas as pd
from optuna import Trial

from src.relativepath import CACHE_DIR

__all__ = ["ProblemSolution", "ProblemSolver", "OptunableProblemSolver"]


_TParams = TypeVar("_TParams")


@dataclass
class ProblemSolution(object):
    """
    Data class storing information about a solution given by a specific solver.

    For more details, see ProblemSolver.
    """

    accuracy: float
    predictions: np.ndarray


class ProblemSolver(Generic[_TParams], ABC):
    """
    An object that stores dataset at creation, receives train parameters when solve(), and outputs a solution
    containing accuracy, classification, etc.

    This abstraction is defined to be tuned by optuna. Conventionally, when solve() is called, a model is
    trained from the ground up on train dataset with new parameters generated by optuna and predictions are made on
    test dataset. A ProblemSolution is returned, which contains the prediction, accuracy, and some extra data to tell
    the optuna how this trial doing.
    """

    @classmethod
    @abstractmethod
    def preprocess_raw(cls, train: str | os.PathLike, test: str | os.PathLike) -> tuple[pd.DataFrame, pd.DataFrame]:
        """
        Preprocess the data at given paths, and returns them.

        Preprocessing procedure (often using PreprocessPipelines) is defined within this method. This allows
        different solvers to have their own preprocessed data.

        This method should not be called directly in most cases. Use preprocess_cached() to get a copy of cached data
        (if any) to improve performance.
        """
        pass

    @classmethod
    @final
    def preprocess_cached(cls, train: str | os.PathLike, test: str | os.PathLike) -> tuple[pd.DataFrame, pd.DataFrame]:
        """
        Get a copy of cached, preprocessed data if any, cache the preprocessed data otherwise.

        This is a final class method that should not be overridden in any cases. To define preprocessing procedure,
        see preprocess_raw(). After that, use this method to take advantage of performance improvements without
        changing a single line of code.

        Conventionally, this method should be called at instance creation (i.e. __init__() function), since loading
        data each time the solve() method is called is not a good idea.
        """
        cache_path = (CACHE_DIR / cls.__name__).with_suffix(".pickle")
        if cache_path.exists():
            with open(cache_path, "rb") as cache:
                return pickle.load(cache)
        data = cls.preprocess_raw(train, test)
        with open(cache_path, "wb") as cache:
            pickle.dump(data, cache)
        return data

    @abstractmethod
    def solve(self, params: _TParams) -> ProblemSolution:
        """
        Solve the problem on given params.

        The datasets are not passed in since they've been preprocessed and stored in __init__() method,
        conventionally. For this particular problem, predictions are asked to be made on a test set without a "right"
        answer, and this method does exactly this.

        There may and may not be some model training and validation logic in this method. It depends. For example,
        the LGBMSolver does model training and validation here because Stratified K-Fold is used and multiple models
        are trained. The final predictions are made by calculating the mean value of probabilities each model made on
        the test set.
        """
        pass


class OptunableProblemSolver(Generic[_TParams], ProblemSolver[_TParams], ABC):
    """
    Solvers whose hyperparameters can be tuned by optuna.

    See ProblemSolver for more detail about solvers.
    """

    @classmethod
    @abstractmethod
    def prepare_parameter(cls, trial: Trial, *args, **kwargs) -> _TParams:
        """
        Generate a params object for a trial.

        This method will be called multiple times to help optuna choosing the best parameters. Since every solver has a
        different Params class, this abstract method is defined to provide more flexibility and extensibility.
        """
        pass
